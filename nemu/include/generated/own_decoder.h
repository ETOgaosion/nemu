    uint32_t inst = (s)->isa.inst.val;
    uint32_t inst_off = inst >> 2;
    uint32_t opcode = inst_off & opcode_mask;
    uint32_t midcode = 0;
    uint32_t frontcode_6 = 0;
    uint32_t frontcode_7 = 0;
    uint32_t frontcode_12 = 0;
    uint32_t front7_mid = 0;
    // below: we follow the order generated by analysis
    switch (opcode) {
    case OPCODE_I_AR:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_I);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_0:
            // addi
            R(rd) = R(rs1) + imm;
            break;
        case MIDCODE_1:
            // slli
            R(rd) = R(rd) = R(rs1) << (imm & 0b111111);
            break;
        case MIDCODE_7:
            // andi
            R(rd) = R(rs1) & imm;
            break;
        case MIDCODE_5:
            frontcode_6 = (inst >> 26);
            switch (frontcode_6) {
            case FRONTCODE_0:
                // srli
                R(rd) = R(rs1) >> (imm & 0b111111);
                break;
            case FRONTCODE6_5:
                // srai
                R(rd) = RS(rs1) >> (imm & 0b111111);
                break;

            default:
                INV(s->pc);
                break;
            }
            break;
        case MIDCODE_3:
            // sltiu
            R(rd) = R(rs1) < (uint64_t)imm;
            break;
        case MIDCODE_4:
            // xori
            R(rd) = R(rs1) ^ imm;
            break;
        case MIDCODE_6:
            // ori
            R(rd) = R(rs1) | imm;
            break;
        case MIDCODE_2:
            // slti
            R(rd) = RS(rs1) < imm;
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_I_LD:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_I);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_3:
            // ld
            R(rd) = Mr(s, R(rs1) + imm, 8);
            break;
        case MIDCODE_2:
            // lw
            R(rd) = sign_extend(Mr(s, R(rs1) + imm, 4), 32);
            break;
        case MIDCODE_4:
            // lbu
            R(rd) = Mr(s, R(rs1) + imm, 1);
            break;
        case MIDCODE_1:
            // lh
            R(rd) = sign_extend(Mr(s, R(rs1) + imm, 2), 16);
            break;
        case MIDCODE_5:
            // lhu
            R(rd) = Mr(s, R(rs1) + imm, 2);
            break;
        case MIDCODE_6:
            // lwu
            R(rd) = Mr(s, R(rs1) + imm, 4);
            break;
        case MIDCODE_0:
            // lb
            R(rd) = sign_extend(Mr(s, R(rs1) + imm, 1), 8);
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_I_AR64:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_I);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_0:
            // addiw
            R(rd) = sign_extend(R(rs1) + imm, 32);
            break;
        case MIDCODE_1:
            // slliw
            R(rd) = sign_extend(R(rs1) << imm, 32);
            break;
        case MIDCODE_5:
            frontcode_7 = (inst >> 25);
            switch (frontcode_7) {
            case FRONTCODE7_6:
                // sraiw
                R(rd) = sign_extend(R32S(rs1) >> (imm & 0b11111), 32);
                break;
            case FRONTCODE_0:
                // srliw
                R(rd) = sign_extend(R32(rs1) >> imm, 32);
                break;

            default:
                INV(s->pc);
                break;
            }
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_S:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_S);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_3:
            // sd
            Mw(s, R(rs1) + imm, 8, R(rs2));
            break;
        case MIDCODE_2:
            // sw
            Mw(s, R(rs1) + imm, 4, R(rs2));
            break;
        case MIDCODE_0:
            // sb
            Mw(s, R(rs1) + imm, 1, R(rs2));
            break;
        case MIDCODE_1:
            // sh
            Mw(s, R(rs1) + imm, 2, R(rs2));
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_B:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_B);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_1:
            // bne
            if (RS(rs1) != RS(rs2)) {
                s->dnpc = s->pc + imm;
            }
            break;
        case MIDCODE_0:
            // beq
            if (RS(rs1) == RS(rs2)) {
                s->dnpc = s->pc + imm;
            }
            break;
        case MIDCODE_4:
            // blt
            if (RS(rs1) < RS(rs2)) {
                s->dnpc = s->pc + imm;
            }
            break;
        case MIDCODE_5:
            // bge
            if (RS(rs1) >= RS(rs2)) {
                s->dnpc = s->pc + imm;
            }
            break;
        case MIDCODE_6:
            // bltu
            if (R(rs1) < R(rs2)) {
                s->dnpc = s->pc + imm;
            }
            break;
        case MIDCODE_7:
            // bgeu
            if (R(rs1) >= R(rs2)) {
                s->dnpc = s->pc + imm;
            }
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_R_AR:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_R);
        frontcode_7 = (inst >> 25);
        midcode = (inst >> 12) & midcode_mask;
        front7_mid = ((frontcode_7 << 3) | (midcode));
        switch (front7_mid) {
        case ADD:
            R(rd) = R(rs1) + R(rs2);
            break;
        case AND:
            R(rd) = R(rs1) & R(rs2);
            break;
        case OR:
            R(rd) = R(rs1) | R(rs2);
            break;
        case SUB:
            R(rd) = R(rs1) - R(rs2);
            break;
        case SLTU:
            R(rd) = R(rs1) < R(rs2);
            break;
        case XOR:
            R(rd) = R(rs1) ^ R(rs2);
            break;
        case MUL:
            R(rd) = R(rs1) * R(rs2);
            break;
        case DIVU:
            R(rd) = R(rs1) / R(rs2);
            break;
        case REMU:
            R(rd) = R(rs1) % R(rs2);
            break;
        case DIV:
            R(rd) = RS(rs1) / RS(rs2);
            break;
        case SLT:
            R(rd) = RS(rs1) < RS(rs2);
            break;
        case SLL:
            R(rd) = R(rs1) << (R(rs2) & 0b111111);
            break;
        case REM:
            R(rd) = RS(rs1) % RS(rs2);
            break;
        case SRL:
            R(rd) = R(rs1) >> (R(rs2) & 0b111111);
            break;
        case SRA:
            R(rd) = RS(rs1) >> (R(rs2) & 0b111111);
            break;
        case MULH:
            R(rd) = (word_t)(((__int128_t)R(rs1) * (__int128_t)R(rs2)) >> 64);
            break;
        case MULHSU:
            R(rd) = (word_t)(((__int128_t)R(rs1) * (__uint128_t)R(rs2)) >> 64);
            break;
        case MULHU:
            R(rd) = (word_t)(((__uint128_t)R(rs1) * (__uint128_t)R(rs2)) >> 64);
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_U_A:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_U);
        // auipc
        R(rd) = s->pc + imm;
        break;
    case OPCODE_R_AR64:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_R);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_0:
            frontcode_7 = (inst >> 25);
            switch (frontcode_7) {
            case FRONTCODE_0:
                // addw
                R(rd) = sign_extend(R(rs1) + R(rs2), 32);
                break;
            case FRONTCODE7_1:
                // mulw
                R(rd) = sign_extend(R(rs1) * R(rs2), 32);
                break;
            case FRONTCODE7_6:
                // subw
                R(rd) = sign_extend(R(rs1) - R(rs2), 32);
                break;

            default:
                INV(s->pc);
                break;
            }
            break;
        case MIDCODE_5:
            frontcode_7 = (inst >> 25);
            switch (frontcode_7) {
            case FRONTCODE_0:
                // srlw
                R(rd) = sign_extend(R32(rs1) >> (R(rs2) & 0b111111), 32);
                break;
            case FRONTCODE7_6:
                // sraw
                R(rd) = sign_extend(R32S(rs1) >> (R(rs2) & 0b111111), 32);
                break;
            case FRONTCODE7_1:
                // divuw
                R(rd) = sign_extend(R32(rs1) / R32(rs2), 32);
                break;

            default:
                INV(s->pc);
                break;
            }
            break;
        case MIDCODE_1:
            // sllw
            R(rd) = sign_extend(R(rs1) << (R(rs2) & 0b111111), 32);
            break;
        case MIDCODE_4:
            // divw
            R(rd) = sign_extend(R32S(rs1) / R32S(rs2), 32);
            break;
        case MIDCODE_6:
            // remw
            R(rd) = sign_extend(R32S(rs1) % R32S(rs2), 32);
            break;
        case MIDCODE_7:
            // remuw
            R(rd) = sign_extend(R32(rs1) % R32(rs2), 32);
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_U_L:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_U);
        // lui
        R(rd) = imm;
        break;
    case OPCODE_J:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_J);
        // JAL
        R(rd) = s->pc + 4;
        s->dnpc = s->pc + imm;
        display_ftrace(s, rd, rs1, rs2, imm);
        break;
    case OPCODE_I_J:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_I);
        // JALR
        s->dnpc = (R(rs1) + imm) & ~(uint64_t)0x1;
        R(rd) = s->pc + 4;
        display_ftrace(s, rd, rs1, rs2, imm);
        break;
    case OPCODE_I_PR:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_I);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_2:
            // csrrs
            {
                word_t *csr_reg = csr(imm);
                word_t tmp = *csr_reg;
                *csr_reg = tmp | R(rs1);
                R(rd) = tmp;
            }
            break;
        case MIDCODE_1:
            // csrrw
            {
                word_t *csr_reg = csr(imm);
                word_t tmp = *csr_reg;
                *csr_reg = R(rs1);
                R(rd) = tmp;
            }
            break;
        case MIDCODE_0:
            frontcode_12 = (inst >> 20);
            switch (frontcode_12) {
            case FRONTCODE_0:
                // ecall
                isa_raise_intr(s, ECALL_M);
                break;
            case FRONTCODE12_10_9_2:
                // mret
                s->dnpc = isa_ret_intr();
                break;
            case FRONTCODE12_1:
                // ebreak
                NEMUTRAP(s->pc, R(reg_a0));
                break;
            case FRONTCODE12_9_2:
                // sret
                INV(s->pc);
                break;

            default:
                INV(s->pc);
                break;
            }
            break;
        case MIDCODE_3:
            // csrrc
            {
                word_t *csr_reg = csr(imm);
                word_t tmp = *csr_reg;
                *csr_reg = tmp & ~R(rs1);
                R(rd) = tmp;
            }
            break;
        case MIDCODE_5:
            // csrrwi
            {
                word_t *csr_reg = csr(imm);
                R(rd) = *csr_reg;
                *csr_reg = rs1;
            }
            break;
        case MIDCODE_6:
            // csrrsi
            {
                word_t *csr_reg = csr(imm);
                R(rd) = *csr_reg;
                *csr_reg = rs1 | *csr_reg;
            }
            break;
        case MIDCODE_7:
            // csrrci
            {
                word_t *csr_reg = csr(imm);
                R(rd) = *csr_reg;
                *csr_reg = *csr_reg & ~rs1;
            }
            break;

        default:
            INV(s->pc);
            break;
        }
        break;
    case OPCODE_I_FENCE:
        decode_operand(s, &rd, &rs1, &rs2, &imm, TYPE_I);
        midcode = (inst >> 12) & midcode_mask;
        switch (midcode) {
        case MIDCODE_0:
            // fence
            fence_op(imm, false);
            break;
        case MIDCODE_1:
            // fence.i
            fence_op(0, true);
            break;

        default:
            INV(s->pc);
            break;
        }
        break;

    default:
        INV(s->pc);
        break;
    }